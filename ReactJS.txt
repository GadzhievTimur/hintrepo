1)React — это JavaScript-библиотека для создания пользовательских интерфейсов.

React используется, если проект будет дополняться/расширяться и поддерживаться командой. Использование этой библиотеки упростит коммуникацию разработчикам и позволит лучше поддерживать код.

также React можно применять к Legacy-проектам, которым предстоит пройти через рефакторинг. Потому что React можно добавлять в уже существующий проект, обновляя кодовую базу постепенно и точечно.

React, возможно, не подойдет для простых приложений (одностраничных и одноразовых сайтов), потому что в этом случае для того, чтобы разобраться с настройкой проекта и окружения, уже понадобится много времени и труда.

Ещё React будет не самым удачным выбором для реализации частей проекта, которые очень чувствительны к потребляемым ресурсам. В этом случае возможно гибридное использование: когда само приложение по большей части написано на React, а требовательные к производительности места с ним не взаимодействуют – библиотека никак не мешает делать такие интеграции. Однако и тут следует подходить к вопросу без фанатизма: React достаточно быстрый в большинстве случаев, а оптимизировать узкие места всегда можно по факту.

*******************************************************************************************

2) компоненты - это независимые части кода. Их можно складывать вместе и использовать несколько раз.
Компоненты проще объявить в виде функции, но также можно и как классы.

Компонентный подход - это способ дополнения HTLM-страницы с помощью компонентов.

Пример:

import React from 'react';

function App() {
return <div>
text
</div>;
}

export default App;

//В принципе, я выигрываю

*******************************************************************************************

3) Это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием.

Такой подход и делает API React декларативным: вы указываете, в каком состоянии должен находиться пользовательский интерфейс, а React добивается, чтобы DOM соответствовал этому состоянию. Это абстрагирует манипуляции с атрибутами, обработку событий и ручное обновление DOM, которые в противном случае пришлось бы использовать при разработке приложения.

Поскольку «виртуальный DOM» — это скорее паттерн, чем конкретная технология, этим термином иногда обозначают разные понятия. В мире React «виртуальный DOM» обычно ассоциируется с React-элементами , поскольку они являются объектами, представляющими пользовательский интерфейс. Тем не менее, React также использует внутренние объекты, называемые «волокнами» (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации «виртуального DOM» в React.

*******************************************************************************************

4) Рендерит React-элемент в DOM-элемент, переданный в аргумент container и возвращает ссылку на компонент (или возвращает null для компонентов без состояния).

Если React-элемент уже был ранее отрендерен в container, то повторный вызов произведёт его обновление и изменит соответствующую часть DOM, чтобы она содержала последние изменения.

Если дополнительно был предоставлен колбэк, он будет вызван после того, как компонент отрендерится или обновится.

*******************************************************************************************

5) props подобен ключу объекта или аргументу функции.

*******************************************************************************************

6) Когда вместо React-element задаётся кастомный элемент (const element = <Welcome name = 'Timur'>;) и выполняется ReactDOM.render() собирает все HTML + JS (JSX) атрибуты в один объект (prop) и передаёт их компоненту (Welcome).

Если задать имя компонента, ипользуя нижний регистр, то React воспримет его за DOM-тэг.

*******************************************************************************************

7) state показывает текущее состояние ЖЦ.
state - это объект, хранящий динамические данные (например текущее время).
State может использоваться только внутри класса, и обычно единственным местом, где возможно назначить this.state, является конструктор.
State обычно применяется для периодического обновления компонента

state изменяется при помощи setState();

Пример:

this.state.comment = 'Hello' - неверно
this.setState(commnet: 'Hello') - верно

*******************************************************************************************

8) state - это объект, хранящий динамические данные (например текущее время)
props - это объект, хранящий стачиские данные (ключ - значение).

State может использоваться только внутри класса, и обычно единственным местом, где вы можете назначить this.state, является конструктор.

Props задаётся в качестве аргумента функции в виде объекта.

*******************************************************************************************

9) с помощью setState()

*******************************************************************************************

10) жизненный цикл - это процесс выполнения компонентами определённых функций, начиная от их создания и удаления.

Есть 3 этапа ЖЦ компонентов:
1 - монтирование; 2 - обновление; 3 - размонтирование.

На 1-м этапе ЖЦ (монтирование) выполняется метод constuctor().
Далее компонент запускает getDerivedStateFromProps(), потом запускается render(), возвращающий JSX. React «монтируется» в DOM. Следующий этап — запуск метода componentDidMount(). Тут происходит выполнение всех асинхронных вызовов к базам данных.
На первом этапе, другими словами, происходит "рождение" компонента.

На 2-м этапе ЖЦ (обновление) также выполняется метод getDerivedStateFromProps(), но уже без constructor()

Потом происходит запуск shouldComponentUpdate(). Тут можно выполнять сравнение старых свойств с новым перечнем свойств либо сравнивать состояния. При этом мы можем указать, надо ли отображать компонент заново, возвращая true либо false — это даст возможность сделать приложение более эффективным благодаря уменьшению числа лишних отображений. Если же shouldComponentUpdate() возвращает false, этап обновлений завершается.

В обратном случае React отобразится заново, а потом запустится getSnapshotBeforeUpdate(). Потом React запустит componentDidUpdate(). Как и в случае с componentDidMount(), его можно применять для асинхронных вызовов либо управления DOM.

На 3-м этапе ЖЦ (размонтирование) Происходит удаление компонента из DOM-React с помощью запуска componentWillUnmount()

Есть ещё 1 метод, который не совсем относится к ЖЦ - это метод getDerivedStateFromError(). Он применяется, когда в компоненте появляется ошибка, происходит запуск getDerivedStateFromError(), в результате появляется возможность обновить состояние, дабы показать, что ошибка имела место быть

*******************************************************************************************

11) события в react и в DOM схожи, за исключением синтаксиса

*******************************************************************************************

12) с помощью refs можно получать доступ к DOM-узлам или React-элементам по ссылке.

Рефы создаются с помощью React.createRef() и прикрепляются к React-элементам через ref атрибут. Обычно рефы присваиваются свойству экземпляра класса в конструкторе, чтобы на них можно было ссылаться из любой части компонента.

refs не всегда нужно использовать, но есть особые случаи, когда это необходимо:
- Управление фокусом, выделение текста или воспроизведение медиа.
- Императивный вызов анимаций.
- Интеграция со сторонними DOM-библиотеками.

*******************************************************************************************

13) Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных уровнях.
Контекст используется, когда есть необходимость многократно задавать какие-либо данные в каждом объекте (например - выбранная пользователем тема).
В случае написания компонента без контекста придётся вписывать значения несколько раз и в конечном итоге это может стать проблемой, да и к тому же код становится в разы больше (громоздким).

Контекст задаётся с помощью React.createContext(defaultValue);
Пример - const MyContext = React.createContext(defaultValue);

*******************************************************************************************

hooks - это возможность использовать все возможности React без написания классов для них.

Хуки используются для того, чтобы разбить компонент на функции по их назначению. Чтобы не создавать ненужное изобилие классов, используются хуки, которые позволяют выполнять все возможности React без загромождения кода.
Хуки можно использовать по собственному желанию и они 100% обратимы, т.е. не будет конфликта версий, т.к. не произодится никаких изменений

